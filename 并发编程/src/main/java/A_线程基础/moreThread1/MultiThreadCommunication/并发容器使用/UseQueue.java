package A_线程基础.moreThread1.MultiThreadCommunication.并发容器使用;import org.junit.Test;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.concurrent.*;public class UseQueue {	/**	 * 高性能无阻塞无界队列：ConcurrentLinkedQueue	 */	@Test	public void ceui1() {		ConcurrentLinkedQueue<String> q = new ConcurrentLinkedQueue<String>();		q.offer("a");		q.offer("b");		q.offer("c");		q.offer("d");		q.add("e");		System.out.println(q.poll());    //a 从头部取出元素，并从队列里删除(长度就从5变成4了)		System.out.println(q.size());    //4		System.out.println(q.peek());    //b 取出来不删除元素		System.out.println(q.size());    //4	}	@Test	public void ceui2() throws InterruptedException {		ArrayBlockingQueue<String> array = new ArrayBlockingQueue<String>(5);		array.put("a");		array.put("b");		array.add("c");		array.add("d");		array.add("e");		array.add("f");//加到f的时候因为元素满了,就报异常了		/**		 * offer参数:		 * 	1.往里面添加的参数		 *    2.时间		 *    3.时间类型(表示第二个参数是什么,不一定是秒,也可以是分钟,小时)		 *    下面的意思是我往里面添加  "a" 元素 , 如果3秒内添加进去了就返回true,否则就返回false		 */		System.out.println(array.offer("a", 3, TimeUnit.SECONDS));	}	@Test	public void ceui3() {		//阻塞队列		LinkedBlockingQueue<String> q = new LinkedBlockingQueue<String>();		q.offer("a");		q.offer("b");		q.offer("c");		q.offer("d");		q.offer("e");		q.add("f");		System.out.println(q.size());//长度 6		/**		 * 循环遍历集合打印		 */		for (Iterator iterator = q.iterator(); iterator.hasNext(); ) {			String string = (String) iterator.next();			System.out.println(string);		}		System.out.println("======================");		List<String> list = new ArrayList<String>();		/**		 * 从q队列中取三个元素放入集合中		 */		System.out.println(q.drainTo(list, 3));		System.out.println(list.size());		for (String string : list) {			System.out.println(string);		}	}	@Test	public void ceui4() {		/**		 * 不能初始化容器个数		 * 队列不允许添加任何元素,添加了会报异常		 */		final SynchronousQueue<String> q = new SynchronousQueue<String>();		Thread t1 = new Thread(new Runnable() {			@Override			public void run() {				try {					System.out.println(q.take());				} catch (InterruptedException e) {					e.printStackTrace();				}			}		});		t1.start();		Thread t2 = new Thread(new Runnable() {			@Override			public void run() {				q.add("asdasd");			}		});		t2.start();	}}